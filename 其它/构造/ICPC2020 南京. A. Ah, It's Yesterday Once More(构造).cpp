/*
$Description$
在一个$20\times20$的网格上，构造一棵树（边是四连通），满足：树上每个点上有一个人，每次随机上下左右走一格（走到树外则原地不动消耗一次），有超过$25\%$的概率$50000$步后所有人不会走到同一个点。
$Solution$
只需尽可能让路径长（是吧？）。
也就是要让空间利用率尽可能高。蛇形路径空间利用率低（约$\frac12$）（可以随机一百次求一下概率），[阶梯型路径](https://zhuanlan.zhihu.com/p/338249705)利用率高就可以过了（约$\frac23$）。

阶梯型拿excel随便搞搞就弄出来了：
![](https://img2020.cnblogs.com/blog/1143196/202102/1143196-20210221155719383-1346724857.png)
主要是注意可以弄这个结构：![](https://img2020.cnblogs.com/blog/1143196/202102/1143196-20210221155816507-166632747.png)
然后能额外扩展的部分就多扩展一下，尽可能覆盖多的格子。

这个题现场只过了6个。。感觉硬猜的话还行吧，不能用excel应该是最大的难题。
提交记录基本都一样，用了$267$个格子或者$240+$，我用了$268$个hhh。
*/
#include <bits/stdc++.h>

int main()
{
	puts("20 20");
	puts("11111101111101111101");
	puts("10010110010110010111");
	puts("01011011011011011001");
	puts("11101101101101101101");
	puts("10110110110110110110");
	puts("11011011011011011011");
	puts("01101101101101101101");
	puts("10110110110110110111");
	puts("10011011011011011001");
	puts("11101101101101101101");
	puts("10110110110110110110");
	puts("11011011011011011011");
	puts("01101101101101101101");
	puts("10110110110110110111");
	puts("10011011011011011001");
	puts("11101101101101101101");
	puts("10110110110110110110");
	puts("11011011011011011011");
	puts("01001101001101001101");
	puts("11110111110111110111");

	return 0;
}
