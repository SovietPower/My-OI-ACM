/*
124ms	8000KB
$Description$
你有$n$个小兵，对方有$m$个小兵，血量给定。随机对场上所有还存活的小兵造成$1$伤害，重复$d$次。求$d$次伤害后对方所有小兵死亡的概率（你的小兵是否存活随意）。
$Solution$
这题不会..我怕不是个傻子...（以为排序后状态数依旧很多）
直接DP，最简单的就是开个10维数组了，复杂度$O(7^10)$。
容易发现具体哪个小兵的血量是多少是无所谓的，只需要记血量为$i$的小兵有多少个，也就是将某时刻的血量排序作为一种状态就可以了。
写个程序算下排序后的状态数，只有462*462=213444个。直接记忆化就ok了。
血量可以七进制来存，也可以用10位longlong+map，或者存每个血量的有多少个（转移方便）。注意剪下枝。
第三种存状态的话s<1e6时敌方就都挂了。（0血量不用存啊。。）
（打ACM就随便用STL了/cy）
*/
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <unordered_map>
#define gc() getchar()
typedef long long LL;
const int N=250005;

namespace TEST
{
	const int N=1e5+5;
	int ans;
	bool v[N];
	int Trans(int x)
	{
		static int a[6];
		for(int i=1; i<=5; ++i,x/=10) a[i]=x%10;
		std::sort(a+1,a+6);
		if(a[5]>6) return 0;
		x=0;
		for(int i=1; i<=5; ++i) x*=10, x+=a[i];
		return x;
	}
	void Main()
	{
		for(int i=0,t; i<100000; ++i)
			if(!v[t=Trans(i)]) v[t]=1, ++ans;
		printf("%d\n",ans);
	}
}

int A[8],B[8];
std::unordered_map<LL,double> f;

inline int read()
{
	int now=0;register char c=gc();
	for(;!isdigit(c);c=gc());
	for(;isdigit(c);now=now*10+c-48,c=gc());
	return now;
}
LL Trans()
{
	LL x=0;
	for(int i=1; i<=6; ++i) x=x*10+B[i];
	for(int i=1; i<=6; ++i) x=x*10+A[i];
	return x;
}
double DFS(LL s,int d)
{
	if(s<1000000) return 1;
	if(f.count(s)) return f[s];
	if(!d) return 0;
	double res=0;
	for(int i=1; i<=6; ++i)
		if(A[i]) --A[i], ++A[i-1], res+=(A[i]+1)*DFS(Trans(),d-1), ++A[i], --A[i-1];
	for(int i=1; i<=6; ++i)
		if(B[i]) --B[i], ++B[i-1], res+=(B[i]+1)*DFS(Trans(),d-1), ++B[i], --B[i-1];
	int sum=0;
	for(int i=1; i<=6; ++i) sum+=A[i]+B[i];
	return f[s]=res/sum;
}

int main()
{
	const int n=read(),m=read(),d=read();
	for(int i=1; i<=n; ++i) ++A[read()];
	for(int i=1; i<=m; ++i) ++B[read()];
	printf("%.9lf\n",DFS(Trans(),d));

	return 0;
}
